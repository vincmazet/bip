# Interpolation

Image interpolation is a basic tool used extensively in tasks such as
rescaling, translating, shrinking or rotating an image.
These tasks are geometric transformations that map an image into a predefined geometry,
for example in remote sensing to return a cartographic reference,
or in medical imaging to align images on anatomical references.
The consequence of a geometric transformation is that the transformed grid points of the input image
no longer coincide with the grid points of the output image and vice-versa.

The basic idea of interpolation is quite simple:
first, reconstruct a "continuous" image from the discrete input image,
then sample this "continuous" image onto the grid of the output image.
Interpolation methods differ from the way the "continuous" image is reconstructed.

```{figure} interpolation.png
---
width: 100%
name: F:interpolation:principle
---
Principle of interpolation.
The green image is the continuous image.
The blue and red grid schematize the input and ouput grids, respectively.
The question is: how to compute the intensity of the pixels of the red grid from the one of the blue grid?
```

<!-- Geometric transformation ? rescale/resize, rotation, translation, stretch, shearing... (cf Jahne fig 10.16 p. 277 + fig 10.15 p. 276) -->

It is more simple to understand image (2D) interpolation by considering 1D interpolation.
Thus the sequel of this section illustrates some interpolation methods in the 1D domain.


## Nearest neighbour interpolation

Nearest neighbour interpolation (French: _interpolation au plus proche voisin_) is the simplest method.
The intensity of a pixel in the output image is assigned to the intensity of the closest pixel in the input image.

{numref}`F:interpolation:nearest-1d` illustrates the principle of nearest neighbour interpolation in a 1-dimensional context.

```{figure} interp-nearest-1d.svg
---
width: 450px
name: F:interpolation:nearest-1d
---
Nearest neighbour interpolation on a 1D example.
The blue dots represent the input image pixels,
the red dots represent the output image pixels.
The gray line is the continuous image reconstructed from the input image.
```

```{figure} interp-nearest-2d.svg
---
width: 100%
name: F:interpolation:nearest-2d
---
Nearest neighbour interpolation on an image with one row
(the pixel intensities have the same intensities as the data in {numref}`F:interpolation:nearest-1d`).
```

## (Bi)linear interpolation

With linear interpolation (French: _interpolation linéaire_),
the interpolated points lie on pieces of straight lines connecting neighbouring grid points.
Because images are in 2D, this method is called <i>bi</i>linear interpolation.
This generally gives better results that nearest neighbour interpolation, but structures with high frequencies are not correctly interpolated.

```{figure} interp-linear-1d.svg
---
width: 450px
name: F:interpolation:linear-1d
---
Linear interpolation on a 1D example.
```

```{figure} interp-linear-2d.svg
---
width: 100%
name: F:interpolation:linear-2d
---
Linear interpolation on an image.
```

## Polynomial Interpolation

The basic principle of linear interpolation was that a straight line was drawn to pass through two neighbouring points.
Besides its porr behavior to interpolate high frequencies,
polynomial interpolation has another signiﬁcant disadvantage:
the interpolated curve is not continuous at the grid points already in its ﬁrst derivative.

Therefore, an alternative is to use a polynomial of degree $P$ that must pass through $P+1$ grid points.

```{figure} interp-cubic-1d.svg
---
width: 450px
name: F:interpolation:cubic-1d
---
Polynomial interpolation on a 1D example.
```

```{figure} interp-cubic-2d.svg
---
width: 100%
name: F:interpolation:cubic-2d
---
Polynomial interpolation on an image.
```




<!-- ## Spline-Based Interpolation

Splines avoid the disadvantage of polynomial interpolation by additional constraints for the continuity of derivatives at the grid points.
Especially, B-splines are separable.
It is sufficient to discuss the properties of 1-D B-splines.
From the background of image processing, the easiest access to B-splines is their convolution property.
The kernel of a P-order B-spline curve is generated by convolving the box function $P+1$ times with itself.

**eq jahne 10.51**

**illustration 1D**
 -->
 
<!-- ## Ideal interpolation

The ideal interpolation function in Eq. (10.34) is separable. Therefore,
interpolation can as easily be formulated for higher-dimensional images.
We can expect that all solutions to the interpolation problem will also
be separable. Consequently, we need only discuss the 1-D interpolation
problem. Once it is solved, we also have a solution for the n-dimensional
interpolation problem.

Interpolation reduces to a simple operation in the Fourier domain.
As shown by **Eq. (10.36)**, the transfer function of an ideal interpolation kernel is a rectangular (box) function
which is zero outside the wave numbers that can be represented.
This basic fact suggests the following interpolation procedure in Fourier space:

1. Enlarge the matrix of the Fourier transformed image.
   If an $M \times M$ matrix is increased to an $M' \times M'$ matrix,
   the image in the spatial domain is also increased to an $M' \times M'$ image.
   Because of the reciprocity of the Fourier transform, the image size remains unchanged.
   Only the spacing between pixels is decreased,
   resulting in a higher spatial resolution.

2. Fill the padded area in the Fourier space with zeroes
   and compute an inverse Fourier transform.

Theoretically, this procedure results in a perfectly interpolated image.
Unfortunately, it has three drawbacks.

1. The Fourier transform of a ﬁnite image
   implies a cyclic repetition of the image in the spatial and Fourier domain.
   Thus, the convolution performed by the Fourier transform is cyclic.
   This means that at the edge of the image,
   convolution continues with the image on the opposite side.
   As the real world is not periodic and interpolation masks are large,
   this may lead to signiﬁcant distortions of the interpolation
   even at quite large distances from the edges of the image.

2. The Fourier transform can be computed eﬃciently
   only for a specified number of values for $M'$.
   Best known are the fast radix-2 algorithms that can be applied
   only to images of the size $M' = 2^{N'}$.
   Therefore, the Fourier transform-based interpolation is slow for numbers $M'$ 
   that cannot be expressed as a product of many small factors.
   
3. As the Fourier transform is a global transform, it can be applied only to scaling.
   According to the generalized similarity theorem,
   it could also be applied to rotation and affine transforms.
   But then the interpolation problem is only shifted
   from the spatial domain to the wave number domain.
 -->



<!-- then this continuous image is filtered so as to give an image whose spectrum is compatible with the new sampling that we wish t carry out,

The basis of interpolation is the sampling theorem (Section 9.2.2).
This theorem states that the digital image completely represents the
continuous image provided the sampling conditions are met. In short
it means that each periodic structure that occurs in the image must be
sampled at least twice per wavelength.

These resampling operations rely on mathematical bases of the Shannon samling theory.

The fact that interpolation is a convolution operation and thus can
be described by a transfer function in Fourier space Eq. (10.36) gives
us a handy tool to rate the errors associated with an interpolation tech-
nique.

 -->



